#pragma once

#include <filesystem>
#include <variant>
#include <map>


#include "primitives/shader_program.h"
#include "assets/textures/texture2d.h"

namespace pgre {
using asset_id_t = uint64_t;

namespace asset_manager_impl {
    asset_id_t get_next_asset_id(){
        static asset_id_t next_id = 0;
        return ++next_id;
    }

    namespace fs = std::filesystem;
    using resource_variant_t = std::variant<std::monostate, std::shared_ptr<texture2D_t>,
                                            std::shared_ptr<shader_t>>;

    class asset_manager_t
    {
        std::unordered_map<asset_id_t, resource_variant_t> id_to_asset{};
        std::map<fs::path, asset_id_t> path_to_id{};
        
    public:
        asset_manager_t() = default;

        template <typename AssetTy, typename... AssetConstArgs>
        std::pair<asset_id_t, std::shared_ptr<AssetTy>> load_or_get(const fs::path& path, AssetConstArgs&&... args) {
            if (path_to_id.contains(path)) {
                auto id = path_to_id.at(path);
                return {id, std::get<AssetTy>(id_to_asset.at(id))};
            }
            auto id = get_next_asset_id();
            path_to_id.emplace(path, id);
            auto asset_ref = std::make_shared<AssetTy>(path, std::forward(args)...);
            id_to_asset.emplace(id, asset_ref);
            return {id, asset_ref};
        }

        template <typename AssetTy>
        std::shared_ptr<AssetTy> get_by_id(asset_id_t id) {
            return std::get<AssetTy>(id_to_asset.at(id));
        }

        template <typename AssetTy>
        std::shared_ptr<AssetTy> get_by_path(const fs::path& path) {
            return std::get<AssetTy>(id_to_asset.at(path_to_id.at(path)));
        }
    };

} // namespace asset_manager_impl

class asset_manager
{
    static asset_manager_impl::asset_manager_t instance;

public:
    //TODO do i even need this asset manager thing?
    
};

} // namespace pgre
